<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Audience Questions - Conference Captioning</title>

    <!-- Bootstrap 5 CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
    <!-- Bootstrap Icons -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.min.css">

    <style>
        body {
            background-color: #f8f9fa;
        }
        .navbar-brand {
            font-weight: bold;
        }
        .page-header {
            border-bottom: 1px solid #dee2e6;
            padding-bottom: 1rem;
            margin-bottom: 2rem;
        }
        #stream-name {
            font-family: 'Courier New', Courier, monospace;
            background-color: #e9ecef;
            padding: 0.1rem 0.5rem;
            border-radius: 0.25rem;
            font-size: 0.9em;
        }
        .question-card {
            background-color: #ffffff;
            border-left: 5px solid #0d6efd;
            border-radius: 0.5rem;
            margin-bottom: 1rem;
            padding: 1.5rem;
            box-shadow: 0 2px 8px rgba(0,0,0,0.06);
            /* Animation for new items */
            animation: fadeIn 0.5s ease;
        }
        .question-meta {
            color: #6c757d;
            font-size: 0.9em;
            margin-bottom: 0.75rem;
        }
        .question-text {
            color: #212529;
            font-size: 1.1em;
            line-height: 1.6;
            word-break: break-word;
        }
        .delete-btn {
            color: #6c757d;
            transition: color 0.2s ease-in-out, transform 0.2s ease;
        }
        .delete-btn:hover {
            color: #dc3545;
            transform: scale(1.1);
        }
        #initial-loader, #error-message, #empty-message {
            display: none; /* Hidden by default */
        }
        .polling-status {
            font-size: 0.8em;
            color: #6c757d;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
    </style>
</head>
<body>

    <nav class="navbar navbar-expand-lg navbar-light bg-white shadow-sm">
        <div class="container">
            <a class="navbar-brand" href="#">
                <i class="bi bi-patch-question-fill"></i>
                Audience Questions
            </a>
            <span class="polling-status" id="polling-status-indicator"></span>
        </div>
    </nav>

    <main class="container my-5">
        <div class="page-header d-flex justify-content-between align-items-center">
            <div>
                <h1 class="h2">Live Question Queue</h1>
                <p class="lead text-muted mb-0">For stream: <strong id="stream-name">...</strong></p>
            </div>
            <button id="delete-all-btn" class="btn btn-outline-danger d-none">
                <i class="bi bi-trash3-fill me-1"></i> Clear All Questions
            </button>
        </div>

        <!-- Message Area: for loading, errors, or empty state -->
        <div id="message-area" class="text-center my-5">
            <div id="initial-loader">
                <div class="spinner-border text-primary" role="status">
                    <span class="visually-hidden">Loading...</span>
                </div>
                <p class="mt-2">Connecting to question stream...</p>
            </div>
            <div id="error-message" class="alert alert-danger"></div>
            <div id="empty-message" class="alert alert-info">
                <i class="bi bi-moon-stars-fill me-2"></i>No questions yet. Waiting for audience input.
            </div>
        </div>

        <!-- Question items will be injected here by JavaScript -->
        <div id="question-list"></div>
    </main>

<script>
document.addEventListener('DOMContentLoaded', () => {
    // --- CONFIGURATION ---
    const API_BASE_URL = "https://api.deafassistant.com/question";
    const POLL_INTERVALS = {
        FAST: 1000,   // 1 second (when new questions arrive)
        MEDIUM: 4000, // 4 seconds (after one cycle with no new questions)
        SLOW: 8000    // 8 seconds (max delay)
    };

    // --- DOM ELEMENT REFERENCES ---
    const questionListEl = document.getElementById('question-list');
    const streamNameEl = document.getElementById('stream-name');
    const initialLoaderEl = document.getElementById('initial-loader');
    const errorMessageEl = document.getElementById('error-message');
    const emptyMessageEl = document.getElementById('empty-message');
    const deleteAllBtn = document.getElementById('delete-all-btn');
    const pollingStatusEl = document.getElementById('polling-status-indicator');

    // --- STATE MANAGEMENT ---
    let streamName, uid;
    let currentPollInterval = POLL_INTERVALS.FAST;
    let pollTimeoutId = null;
    let knownQuestionIds = new Set();
    let isInitialLoad = true;

    // --- INITIALIZATION ---
    function initialize() {
        const urlParams = new URLSearchParams(window.location.search);
        streamName = urlParams.get('streamName');
        uid = urlParams.get('uid');

        if (!streamName || !uid) {
            displayError("Missing 'streamName' or 'uid' in the URL. Please provide them as query parameters to view questions.");
            return;
        }

        streamNameEl.textContent = streamName;
        questionListEl.addEventListener('click', handleDeleteClick);
        deleteAllBtn.addEventListener('click', handleDeleteAll);
        
        pollForQuestions();
    }

    // --- UI HELPER FUNCTIONS ---
    function showInitialLoader(isLoading) {
        initialLoaderEl.style.display = isLoading ? 'block' : 'none';
        if (isLoading) {
            errorMessageEl.style.display = 'none';
            emptyMessageEl.style.display = 'none';
        }
    }

    function displayError(message) {
        stopPolling();
        showInitialLoader(false);
        errorMessageEl.textContent = message;
        errorMessageEl.style.display = 'block';
        emptyMessageEl.style.display = 'none';
        pollingStatusEl.textContent = 'Disconnected';
        pollingStatusEl.style.color = '#dc3545';
    }
    
    function showEmptyMessage(show) {
        emptyMessageEl.style.display = show ? 'block' : 'none';
        deleteAllBtn.classList.toggle('d-none', show);
    }
    
    function updatePollingStatus() {
        pollingStatusEl.textContent = `Updating every ${currentPollInterval / 1000}s`;
        pollingStatusEl.style.color = '#6c757d';
    }

    // --- POLLING & DATA HANDLING ---
    
    function stopPolling() {
        if (pollTimeoutId) clearTimeout(pollTimeoutId);
    }

    function scheduleNextPoll() {
        stopPolling(); // Ensure no multiple loops are running
        pollTimeoutId = setTimeout(pollForQuestions, currentPollInterval);
        updatePollingStatus();
    }
    
    /**
     * Fetches questions and triggers UI updates. Manages the adaptive polling interval.
     * API Call based on Step 2 in your Python script:
     * GET /GetStreamQuestions?uid={uid}&streamName={streamName}
     */
    async function pollForQuestions() {
        if (isInitialLoad) {
            showInitialLoader(true);
        }
        
        const url = new URL(`${API_BASE_URL}/GetStreamQuestions`);
        url.search = new URLSearchParams({ streamName, uid });

        try {
            const response = await fetch(url);
            if (!response.ok) {
                // Handle specific errors like 404 for a more graceful stop
                if (response.status === 404) {
                     throw new Error(`Stream not found or you don't have permission. Please check the stream name and UID.`);
                }
                throw new Error(`API Error: ${response.status} ${response.statusText}`);
            }
            const newQuestions = await response.json();
            
            // --- Adaptive Polling Logic ---
            const newQuestionIds = new Set(newQuestions.map(q => q.id));
            const hasNewData = newQuestions.length > knownQuestionIds.size; // Simple but effective check

            if (hasNewData) {
                currentPollInterval = POLL_INTERVALS.FAST;
            } else if (currentPollInterval === POLL_INTERVALS.FAST) {
                currentPollInterval = POLL_INTERVALS.MEDIUM;
            } else {
                currentPollInterval = POLL_INTERVALS.SLOW;
            }

            renderQuestions(newQuestions);
            knownQuestionIds = newQuestionIds;

        } catch (error) {
            console.error('Polling failed:', error);
            displayError(error.message);
            return; // Stop polling on error
        } finally {
            if (isInitialLoad) {
                showInitialLoader(false);
                isInitialLoad = false;
            }
            scheduleNextPoll();
        }
    }

    /**
     * Efficiently updates the DOM to reflect the current list of questions.
     * It only adds/removes elements that have changed, preventing screen flicker.
     */
    function renderQuestions(questions) {
        const questionElements = new Map(
            [...questionListEl.children].map(el => [el.dataset.id, el])
        );
        const incomingIds = new Set();

        // Add new or update existing questions
        questions.forEach(q => {
            incomingIds.add(q.id);
            if (!questionElements.has(q.id)) {
                const card = createQuestionCard(q);
                questionListEl.prepend(card); // Prepend to show newest on top
            }
        });

        // Remove old questions that were deleted
        questionElements.forEach((el, id) => {
            if (!incomingIds.has(id)) {
                el.remove();
            }
        });
        
        // Update the empty message visibility
        showEmptyMessage(questions.length === 0);
    }
    
    function createQuestionCard(item) {
        const card = document.createElement('div');
        card.className = 'question-card';
        card.dataset.id = item.id;

        const formattedDate = new Date(item.creationTime).toLocaleTimeString(undefined, {
            hour: '2-digit',
            minute: '2-digit',
            second: '2-digit'
        });

        card.innerHTML = `
            <div class="d-flex justify-content-between align-items-start">
                <div>
                    <div class="question-meta">
                        <i class="bi bi-clock me-1"></i> Asked at ${formattedDate}
                    </div>
                    <p class="question-text mb-0">${item.question}</p>
                </div>
                <button class="btn btn-link delete-btn p-0 ms-3" title="Mark as Answered & Remove">
                    <i class="bi bi-check-circle-fill fs-4"></i>
                </button>
            </div>
        `;
        return card;
    }

    // --- EVENT HANDLERS for Deletion ---

    /**
     * Handles clicks on individual delete buttons.
     * API Call based on Step 3 in your Python script:
     * POST /DelQuestion?streamName={streamName}&uid={uid}&id={id}
     */
    async function handleDeleteClick(event) {
        const deleteButton = event.target.closest('.delete-btn');
        if (!deleteButton) return;

        const card = deleteButton.closest('.question-card');
        const questionId = card.dataset.id;

        // No confirmation needed for quick "done" action
        card.style.opacity = '0.5';
        deleteButton.disabled = true;

        const url = new URL(`${API_BASE_URL}/DelQuestion`);
        url.search = new URLSearchParams({ streamName, uid, id: questionId });

        try {
            const response = await fetch(url, { method: 'POST' });
            if (!response.ok) throw new Error('API failed to delete question.');
            
            // Success: remove from DOM immediately for instant feedback
            card.remove();
            knownQuestionIds.delete(questionId);
            if (questionListEl.children.length === 0) {
                showEmptyMessage(true);
            }
        } catch (error) {
            console.error('Failed to delete question:', error);
            alert('Could not remove the question. It may be re-appear on the next refresh.');
            card.style.opacity = '1'; // Restore on failure
            deleteButton.disabled = false;
        }
    }
    
    /**
     * Deletes all questions for the stream.
     * API Call based on Step 5 in your Python script:
     * POST /DelStreamQuestions?streamName={streamName}&uid={uid}
     */
    async function handleDeleteAll() {
        if (!confirm('ARE YOU SURE you want to clear the entire question queue? This cannot be undone.')) {
            return;
        }
        
        deleteAllBtn.disabled = true;
        deleteAllBtn.innerHTML = `<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Clearing...`;

        const url = new URL(`${API_BASE_URL}/DelStreamQuestions`);
        url.search = new URLSearchParams({ streamName, uid });

        try {
            const response = await fetch(url, { method: 'POST' });
            if (!response.ok) throw new Error('API failed to delete all questions.');

            // Success: clear UI and state immediately
            questionListEl.innerHTML = '';
            knownQuestionIds.clear();
            showEmptyMessage(true);

        } catch (error) {
            console.error('Failed to delete all questions:', error);
            alert('Could not clear the queue. Please try again.');
        } finally {
            deleteAllBtn.disabled = false;
            deleteAllBtn.innerHTML = `<i class="bi bi-trash3-fill me-1"></i> Clear All Questions`;
        }
    }

    // --- START THE APP ---
    initialize();
});
</script>
</body>
</html>